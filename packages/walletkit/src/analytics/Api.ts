/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

/** The event is fired on SSE connection failure or unexpected disconnect. */
export interface BridgeConnectErrorEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** Error code. */
  error_code?: number;
  /** Error text. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-connect-error" */
  event_name?: "bridge-connect-error";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** The event is fired when the bridge returns HTTP 200 OK and SSE handshake succeeds. */
export interface BridgeConnectEstablishedEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-connect-established" */
  event_name?: "bridge-connect-established";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** The event is fired when the dApp initiates the SSE connection via GET /events?client_id=... method. */
export interface BridgeConnectStartedEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-connect-started" */
  event_name?: "bridge-connect-started";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** When wallet sends response to bridge (SSE stream). */
export interface BridgeRequestDecodeErrorEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** Error code. */
  error_code?: number;
  /** Error message. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-request-decode-error" */
  event_name?: "bridge-request-decode-error";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** When dApp POSTs a request to /message. */
export interface BridgeRequestReceivedEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-request-received" */
  event_name?: "bridge-request-received";
  /** Message ID. */
  message_id?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Request type. */
  request_type?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** When dApp POSTs a request to /message. */
export interface BridgeRequestSentEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-request-sent" */
  event_name?: "bridge-request-sent";
  /** Message ID. */
  message_id?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Request type. */
  request_type?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** When bridge fails to decrypt or parse wallet's response. */
export interface BridgeResponseDecodeErrorEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** Error code. */
  error_code?: number;
  /** Error message. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-response-decode-error" */
  event_name?: "bridge-response-decode-error";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** When wallet sends response to bridge (SSE stream). */
export interface BridgeResponseReceivedEvent {
  /** Bridge URL. */
  bridge_url?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "bridge-response-received" */
  event_name?: "bridge-response-received";
  /** Message ID. */
  message_id?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Request type. */
  request_type?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** Fired when a user successfully connected a wallet. */
export interface ConnectionCompletedEvent {
  /** Time spent to connect to the TON Connect bridge (milliseconds). */
  bridge_connect_duration?: number;
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "connection-completed" */
  event_name?: "connection-completed";
  /** User locale. */
  locale?: string;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page. */
  origin_url?: string;
  /**
   * OS and platform name, it is recommended to use unified standard.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** true if the user has TG Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet address in raw format in lower case. */
  wallet_address?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique session ID on the wallet side.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
  /**
   * Wallet account state init.
   * @format base64
   * @example ""
   */
  wallet_state_init?: string;
}

/** Created when an error occurred during connection flow. */
export interface ConnectionErrorEvent {
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** Error code. */
  error_code?: number;
  /** Error message. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "connection-error" */
  event_name?: "connection-error";
  /** User locale. */
  locale?: string;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page. */
  origin_url?: string;
  /**
   * OS and platform name, it is recommended to use unified standard.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** true if the user has TG Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /**
   * Unique session ID on the wallet side.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** This event should be sent when a user selected and forwarded to the wallet app. */
export interface ConnectionSelectedWalletEvent {
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "connection-selected-wallet" */
  event_name?: "connection-selected-wallet";
  /** User locale. */
  locale?: string;
  /** List of the wallets on the main screen. */
  main_screen?: string[];
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page (excluding query and hash part of the URL). */
  origin_url?: string;
  /**
   * OS and platform name based on the TON Connect categories. If it is impossible to determine a platform the unknown value should be used.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** Whether the user has Telegram Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** URL used to open the wallet without client_id. */
  wallet_redirect_link?: string;
  /**
   * Redirect method: tg_link, external_link.
   * @example "external_link"
   */
  wallet_redirect_method?: string;
  /**
   * One of explicit_wallet, main_screen, other_wallets.
   * @example "main_screen"
   */
  wallets_menu?: string;
}

/** This event should be sent when a user begins the wallet connection process. */
export interface ConnectionStartedEvent {
  /** Time spent to connect to the TON Connect bridge (milliseconds). */
  bridge_connect_duration?: number;
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "connection-started" */
  event_name?: "connection-started";
  /** User locale. */
  locale?: string;
  /** List of the wallets on the main screen. */
  main_screen?: string[];
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page (excluding query and hash part of the URL). */
  origin_url?: string;
  /**
   * OS and platform name based on the TON Connect categories. If it is impossible to determine a platform the unknown value should be used.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** Whether the user has Telegram Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
}

/** Created when a user initiated disconnection of the wallet. */
export interface DisconnectionEvent {
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "disconnection" */
  event_name?: "disconnection";
  /** User locale. */
  locale?: string;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page. */
  origin_url?: string;
  /**
   * OS and platform name, it is recommended to use unified standard.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** true if the user has TG Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet address in raw format in lower case. */
  wallet_address?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique session ID on the wallet side.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
  /**
   * Wallet account state init.
   * @format base64
   * @example ""
   */
  wallet_state_init?: string;
}

/** Whenever the dApp invokes window[bridgeKey].tonconnect.method(...). */
export interface JSBridgeCallEvent {
  /** Bridge key from wallet list json. */
  bridge_key?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "js-bridge-call" */
  event_name?: "js-bridge-call";
  /**
   * Method (connect, restoreConnection, send, listen).
   * @example "connect"
   */
  js_bridge_method?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the JS bridge returns a promise from the method call. */
export interface JSBridgeErrorEvent {
  /** Bridge key from wallet list json. */
  bridge_key?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** Error code. */
  error_code?: number;
  /** Error message */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "js-bridge-error" */
  event_name?: "js-bridge-error";
  /**
   * Method (connect, restoreConnection, send, listen).
   * @example "connect"
   */
  js_bridge_method?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the JS bridge returns a promise from the method call. */
export interface JSBridgeResponseEvent {
  /** Bridge key from wallet list json. */
  bridge_key?: string;
  /**
   * The client environment.
   * @example "bridge"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "js-bridge-response" */
  event_name?: "js-bridge-response";
  /**
   * Method (connect, restoreConnection, send, listen).
   * @example "connect"
   */
  js_bridge_method?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "bridge"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

export interface Message {
  address?: string;
  amount?: number;
  payload?: string;
}

export interface TONConnectEvent {
  bridge_connect_duration?: number;
  bridge_key?: string;
  bridge_url?: string;
  browser?: string;
  callback_return_action?: string;
  /** @example "web" */
  client_environment?: string;
  client_id?: string;
  /** @example 0 */
  client_timestamp?: number;
  dapp_name?: string;
  decline_reason?: string;
  emulation_success?: boolean;
  /**
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  error_code?: number;
  error_message?: string;
  /** @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3" */
  event_id?: string;
  /** @example "connection-started" */
  event_name?: "connection-started";
  is_ton_addr?: boolean;
  is_ton_proof?: boolean;
  /** @example "connect" */
  js_bridge_method?: string;
  locale?: string;
  main_screen?: string[];
  manifest_json_url?: string;
  message_id?: string;
  messages?: Message[];
  /** @example "-3" */
  network_id?: string;
  /**
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  normalized_hash?: string;
  origin_url?: string;
  payload?: string;
  /** @example "browser" */
  platform?: string;
  proof_payload_size?: number;
  request_type?: string;
  /**
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  signed_boc?: string;
  /** @example "dapp" */
  subsystem?: string;
  tg_id?: number;
  tma_is_premium?: boolean;
  /** @example "00000000-0000-0000-0000-000000000000" */
  trace_id?: string;
  /** @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3" */
  user_id?: string;
  /** @example 1756253085 */
  valid_until?: number;
  /** @example "ok" */
  verification_result?: string;
  version?: string;
  versions?: Record<string, string>;
  wallet_address?: string;
  wallet_app_name?: string;
  wallet_app_version?: string;
  /**
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
  wallet_redirect_link?: string;
  /** @example "external_link" */
  wallet_redirect_method?: string;
  /**
   * @format base64
   * @example ""
   */
  wallet_state_init?: string;
  /** @example "main_screen" */
  wallets_menu?: string;
}

/** Created when a user sends a transaction for signature. */
export interface TransactionSentEvent {
  /** Time spent to connect to the TON Connect bridge (milliseconds). */
  bridge_connect_duration?: number;
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Hash of the encrypted message.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "transaction-sent" */
  event_name?: "transaction-sent";
  /** User locale. */
  locale?: string;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page. */
  origin_url?: string;
  /**
   * OS and platform name, it is recommended to use unified standard.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** true if the user has TG Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet address in raw format in lower case. */
  wallet_address?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique session ID on the wallet side.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
  /**
   * Wallet account state init.
   * @format base64
   * @example ""
   */
  wallet_state_init?: string;
}

/** Created when a user signed a transaction successfully. */
export interface TransactionSignedEvent {
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "transaction-signed" */
  event_name?: "transaction-signed";
  /** User locale. */
  locale?: string;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page. */
  origin_url?: string;
  /**
   * OS and platform name, it is recommended to use unified standard.
   * @example "browser"
   */
  platform?: string;
  /**
   * Bag of cells with a signed external message.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  signed_boc?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** true if the user has TG Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet address in raw format in lower case. */
  wallet_address?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique session ID on the wallet side.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
  /**
   * Wallet account state init.
   * @format base64
   * @example ""
   */
  wallet_state_init?: string;
}

/** Created when a user signed a transaction successfully. */
export interface TransactionSigningFailedEvent {
  /** Browser name: TB (Telegram browser), TMA (Telegram mini-app), BIW (Browser in wallet), Chrome, Mozilla,... The values are based on the TON Connect categories. */
  browser?: string;
  /**
   * The client environment.
   * @example "web"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** Error code. */
  error_code?: number;
  /** Error message. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "transaction-signing-failed" */
  event_name?: "transaction-signing-failed";
  /** User locale. */
  locale?: string;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /** Array of message objects. */
  messages?: Message[];
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** URL of the current page. */
  origin_url?: string;
  /**
   * OS and platform name, it is recommended to use unified standard.
   * @example "browser"
   */
  platform?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /** true if the user has TG Premium. */
  tma_is_premium?: boolean;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * Timestamp for transaction expiration.
   * @example 1756253085
   */
  valid_until?: number;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet address in raw format in lower case. */
  wallet_address?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique session ID on the wallet side.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
  /**
   * Wallet account state init.
   * @format base64
   * @example ""
   */
  wallet_state_init?: string;
}

/** When the user approves the connection in the wallet. */
export interface WalletConnectAcceptedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-connect-accepted" */
  event_name?: "wallet-connect-accepted";
  /** ton_addr flag. */
  is_ton_addr?: boolean;
  /** Is proof was used. */
  is_ton_proof?: boolean;
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /** Size of the proof payload in bytes. */
  proof_payload_size?: number;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * unknown, ok, warning, danger.
   * @example "ok"
   */
  verification_result?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the user approves the connection in the wallet. */
export interface WalletConnectRejectedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-connect-rejected" */
  event_name?: "wallet-connect-rejected";
  /** ton_addr flag. */
  is_ton_addr?: boolean;
  /** Is proof was used. */
  is_ton_proof?: boolean;
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /** Size of the proof payload in bytes. */
  proof_payload_size?: number;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * unknown, ok, warning, danger.
   * @example "ok"
   */
  verification_result?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the wallet receives a connection request from the dApp. */
export interface WalletConnectRequestReceivedEvent {
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-connect-request-received" */
  event_name?: "wallet-connect-request-received";
  /** ton_addr flag. */
  is_ton_addr?: boolean;
  /** Is proof was used. */
  is_ton_proof?: boolean;
  /** TON Connect manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Size of the proof payload in bytes */
  proof_payload_size?: number;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the wallet displays UI asking the user to confirm the connection. */
export interface WalletConnectRequestUIDisplayedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-connect-request-ui-displayed" */
  event_name?: "wallet-connect-request-ui-displayed";
  /** ton_addr flag. */
  is_ton_addr?: boolean;
  /** Is proof was used. */
  is_ton_proof?: boolean;
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /** Size of the proof payload in bytes. */
  proof_payload_size?: number;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * unknown, ok, warning, danger.
   * @example "ok"
   */
  verification_result?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the wallet sends the connection approval/rejection to the dApp. */
export interface WalletConnectResponseSentEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-connect-response-sent" */
  event_name?: "wallet-connect-response-sent";
  /** ton_addr flag. */
  is_ton_addr?: boolean;
  /** Is proof was used. */
  is_ton_proof?: boolean;
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /** Size of the proof payload in bytes. */
  proof_payload_size?: number;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * unknown, ok, warning, danger.
   * @example "ok"
   */
  verification_result?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the user approves the data signing in the wallet. */
export interface WalletSignDataAcceptedEvent {
  /** (ret param from connection request) */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-sign-data-accepted" */
  event_name?: "wallet-sign-data-accepted";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the wallet displays the sign-data confirmation UI. */
export interface WalletSignDataConfirmationUIDisplayedEvent {
  /** (ret param from connection request) */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-sign-data-confirmation-ui-displayed" */
  event_name?: "wallet-sign-data-confirmation-ui-displayed";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * Verification result.
   * @example "ok"
   */
  verification_result?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the wallet receives a sign-data request from the dApp. */
export interface WalletSignDataRequestReceivedEvent {
  /** (ret param from connection request) */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-sign-data-request-received" */
  event_name?: "wallet-sign-data-request-received";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the wallet sends the signed data to the dApp. */
export interface WalletSignDataSentEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-sign-data-sent" */
  event_name?: "wallet-sign-data-sent";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the user approves the transaction in the wallet. When the wallet receives a transaction request from the dApp. */
export interface WalletTransactionAcceptedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-transaction-accepted" */
  event_name?: "wallet-transaction-accepted";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the wallet displays the transaction confirmation UI. */
export interface WalletTransactionConfirmationUIDisplayedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /** Emulation status. */
  emulation_success?: boolean;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /** Error code. */
  error_code?: number;
  /** For emulation errors. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-transaction-confirmation-ui-displayed" */
  event_name?: "wallet-transaction-confirmation-ui-displayed";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /** serialized JSON (only in case emulation is failed). */
  payload?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /**
   * unknown, ok, warning, danger.
   * @example "ok"
   */
  verification_result?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the user rejects the transaction in the wallet. */
export interface WalletTransactionDeclinedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /** Decline reason. */
  decline_reason?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-transaction-declined" */
  event_name?: "wallet-transaction-declined";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /** serialized JSON. */
  payload?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the wallet receives a transaction request from the dApp. */
export interface WalletTransactionRequestReceivedEvent {
  /** (ret param from connection request). */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-transaction-request-received" */
  event_name?: "wallet-transaction-request-received";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

/** When the wallet submits the signed transaction to the network. */
export interface WalletTransactionSentBridgeEvent {
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /** Bridge response code. */
  error_code?: number;
  /** Bridge response message. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-transaction-sent-bridge" */
  event_name?: "wallet-transaction-sent-bridge";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * Normalized transaction hash.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  normalized_hash?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the wallet submits the signed transaction to the network. */
export interface WalletTransactionSentEvent {
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** RPC response code. */
  error_code?: number;
  /** RPC response message. */
  error_message?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-transaction-sent" */
  event_name?: "wallet-transaction-sent";
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /**
   * Normalized transaction hash (encoded as base64).
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  normalized_hash?: string;
  /**
   * In case of failure.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  signed_boc?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
}

/** When the user rejects the data signing request in the wallet. */
export interface ApiWalletSignDataDeclinedEvent {
  /** (ret param from connection request) */
  callback_return_action?: string;
  /**
   * The client environment.
   * @example "wallet"
   */
  client_environment?: string;
  /** A unique session ID. */
  client_id?: string;
  /**
   * The timestamp of the event on the client side, in Unix time (stored as an integer).
   * @example 0
   */
  client_timestamp?: number;
  /** dApp name from the manifest. */
  dapp_name?: string;
  /**
   * Hash of encrypted message received from the dApp.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  encrypted_message_hash?: string;
  /**
   * Unique random event UUID generated by the sender. Used for deduplication on the backend side.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  event_id?: string;
  /** @example "wallet-sign-data-declined" */
  event_name?: "wallet-sign-data-declined";
  /** Manifest URL. */
  manifest_json_url?: string;
  /**
   * Network id (-239 for the mainnet and -3 for the testnet). Other values should be rejected.
   * @example "-3"
   */
  network_id?: string;
  /** Origin URL from the manifest. */
  origin_url?: string;
  /**
   * The subsystem used to collect the event (possible values: dapp, bridge, wallet).
   * @example "dapp"
   */
  subsystem?: string;
  /**
   * ID to aggregate multiple events into one trace. UUIDv7 must be used (first 48 bits must be unix_ts_ms as in the specification). trace_id older than 24h won't be accepted.
   * @example "00000000-0000-0000-0000-000000000000"
   */
  trace_id?: string;
  /**
   * A unique identifier for the user (refer to subsystem session details for more information). May be omitted, in this case it will be generated on the backend side and generated. UUID must be used.
   * @example "8d5e90bd-d6f8-4ab0-bff8-0ee2f26b44c3"
   */
  user_id?: string;
  /** The version of the sending subsystem. */
  version?: string;
  /** Wallet app name. */
  wallet_app_name?: string;
  /** Wallet app version. */
  wallet_app_version?: string;
  /**
   * Unique wallet ID.
   * @format base64
   * @example "ZXhhbXBsZQ=="
   */
  wallet_id?: string;
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<
  FullRequestParams,
  "body" | "method" | "query" | "path"
>;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown>
  extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json",
  JsonApi = "application/vnd.api+json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) =>
    fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter(
      (key) => "undefined" !== typeof query[key],
    );
    return keys
      .map((key) =>
        Array.isArray(query[key])
          ? this.addArrayQueryParam(query, key)
          : this.addQueryParam(query, key),
      )
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.JsonApi]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.Text]: (input: any) =>
      input !== null && typeof input !== "string"
        ? JSON.stringify(input)
        : input,
    [ContentType.FormData]: (input: any) => {
      if (input instanceof FormData) {
        return input;
      }

      return Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
              ? JSON.stringify(property)
              : `${property}`,
        );
        return formData;
      }, new FormData());
    },
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(
    params1: RequestParams,
    params2?: RequestParams,
  ): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (
    cancelToken: CancelToken,
  ): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<HttpResponse<T, E>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(
      `${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`,
      {
        ...requestParams,
        headers: {
          ...(requestParams.headers || {}),
          // ...(type && type !== ContentType.FormData
          //   ? { "Content-Type": type }
          //   : {}),
        },
        signal:
          (cancelToken
            ? this.createAbortSignal(cancelToken)
            : requestParams.signal) || null,
        body:
          typeof body === "undefined" || body === null
            ? null
            : payloadFormatter(body),
      },
    ).then(async (response) => {
      const r = response as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const responseToParse = responseFormat ? response.clone() : response;
      const data = !responseFormat
        ? r
        : await responseToParse[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data;
    });
  };
}

/**
 * @title No title
 * @contact
 */
export class Api<
  SecurityDataType extends unknown,
> extends HttpClient<SecurityDataType> {
  events = {
    /**
     * No description
     *
     * @name EventsCreate
     * @request POST:/events
     */
    eventsCreate: (
      events: (
        | BridgeConnectErrorEvent
        | BridgeConnectEstablishedEvent
        | BridgeConnectStartedEvent
        | BridgeRequestDecodeErrorEvent
        | BridgeRequestReceivedEvent
        | BridgeRequestSentEvent
        | BridgeResponseDecodeErrorEvent
        | BridgeResponseReceivedEvent
        | ConnectionCompletedEvent
        | ConnectionErrorEvent
        | ConnectionSelectedWalletEvent
        | ConnectionStartedEvent
        | DisconnectionEvent
        | JSBridgeCallEvent
        | JSBridgeErrorEvent
        | JSBridgeResponseEvent
        | TONConnectEvent
        | TransactionSentEvent
        | TransactionSignedEvent
        | TransactionSigningFailedEvent
        | WalletConnectAcceptedEvent
        | WalletConnectRejectedEvent
        | WalletConnectRequestReceivedEvent
        | WalletConnectRequestUIDisplayedEvent
        | WalletConnectResponseSentEvent
        | WalletSignDataAcceptedEvent
        | WalletSignDataConfirmationUIDisplayedEvent
        | WalletSignDataRequestReceivedEvent
        | WalletSignDataSentEvent
        | WalletTransactionAcceptedEvent
        | WalletTransactionConfirmationUIDisplayedEvent
        | WalletTransactionDeclinedEvent
        | WalletTransactionRequestReceivedEvent
        | WalletTransactionSentBridgeEvent
        | WalletTransactionSentEvent
        | ApiWalletSignDataDeclinedEvent
      )[],
      params: RequestParams = {},
    ) =>
      this.request<any, any>({
        path: `/events`,
        method: "POST",
        body: events,
        type: ContentType.Json,
        ...params,
        credentials: 'include',
      }),
  };
}
