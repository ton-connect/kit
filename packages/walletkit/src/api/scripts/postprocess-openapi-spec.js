#!/usr/bin/env node
/**
 * Post-processes OpenAPI spec:
 * 1. Fixes number types with integer formats (number + int* format ‚Üí integer)
 * 2. Adds vendor extensions for discriminated unions
 * 
 * Usage: node postprocess-openapi-spec.js <input-openapi.json> [output-openapi.json]
 */

const fs = require('fs');

const inputFile = process.argv[2];
const outputFile = process.argv[3] || inputFile;

if (!inputFile) {
    console.error('Usage: node postprocess-openapi-spec.js <input-openapi.json> [output-openapi.json]');
    process.exit(1);
}

// ============================================================================
// Step 1: Fix Integer Types
// ============================================================================

const INTEGER_FORMATS = ['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'uint8', 'uint16', 'uint32', 'uint64'];

/**
 * Recursively fix number types with integer formats to use 'integer' type
 */
function fixIntegerTypes(obj) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    
    // Handle arrays
    if (Array.isArray(obj)) {
        return obj.map(fixIntegerTypes);
    }
    
    // Check if this is a number type with integer format
    if (obj.type === 'number' && obj.format && INTEGER_FORMATS.includes(obj.format)) {
        obj.type = 'integer';
    }
    
    // Check if this is an array with number items that have integer format
    if (obj.type === 'array' && obj.items) {
        if (obj.items.type === 'number' && obj.items.format && INTEGER_FORMATS.includes(obj.items.format)) {
            obj.items.type = 'integer';
        }
        // Recursively process items
        obj.items = fixIntegerTypes(obj.items);
    }
    
    // Recursively process all properties
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && typeof obj[key] === 'object') {
            obj[key] = fixIntegerTypes(obj[key]);
        }
    }
    
    return obj;
}

// ============================================================================
// Step 2: Enrich Discriminated Unions
// ============================================================================

/**
 * Convert snake_case to camelCase
 */
function snakeToCamel(str) {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Get associated value info for a specific enum case within an allOf/oneOf structure.
 * Returns { hasAssociatedValue: boolean, valueSchema?: object }
 */
function getCaseValueInfo(allOfArray, caseValue) {
    for (const allOfItem of allOfArray) {
        if (!allOfItem.oneOf) continue;
        
        for (const oneOfItem of allOfItem.oneOf) {
            if (!oneOfItem.allOf) continue;
            
            for (const innerAllOf of oneOfItem.allOf) {
                const typeEnum = innerAllOf.properties?.type?.enum;
                if (typeEnum && typeEnum.length === 1 && typeEnum[0] === caseValue) {
                    // Found the matching case, check if it has a value property
                    const valueSchema = innerAllOf.properties?.value;
                    if (valueSchema) {
                        return { hasAssociatedValue: true, valueSchema };
                    }
                    // Check sibling allOf items for the value
                    for (const sibling of oneOfItem.allOf) {
                        if (sibling.properties?.value) {
                            return { hasAssociatedValue: true, valueSchema: sibling.properties.value };
                        }
                    }
                }
            }
        }
    }
    return { hasAssociatedValue: false };
}

/**
 * Check if a schema is an anyOf-based discriminated union pattern.
 * This pattern is generated by ts-json-schema-generator WITHOUT @discriminator.
 * 
 * Pattern (JSON Schema with const):
 * {
 *   "anyOf": [
 *     { "properties": { "type": { "const": "value1" } }, ... },
 *     { "properties": { "type": { "const": "value2" }, "value": {...} }, ... },
 *   ]
 * }
 * 
 * Pattern (OpenAPI with single-value enum):
 * {
 *   "anyOf": [
 *     { "properties": { "type": { "enum": ["value1"] } }, ... },
 *     { "properties": { "type": { "enum": ["value2"] }, "value": {...} }, ... },
 *   ]
 * }
 */
function processAnyOfDiscriminatedUnion(schema, schemaName, allSchemas) {
    // Must have anyOf array
    if (!schema.anyOf || !Array.isArray(schema.anyOf) || schema.anyOf.length < 2) return false;
    
    // Check if all anyOf items have a "type" property with "const" or single-value "enum"
    const cases = [];
    for (const item of schema.anyOf) {
        // Check for const value
        let typeValue = item.properties?.type?.const;
        
        // If no const, check for single-value enum (OpenAPI format)
        if (!typeValue) {
            const enumValues = item.properties?.type?.enum;
            if (enumValues && Array.isArray(enumValues) && enumValues.length === 1) {
                typeValue = enumValues[0];
            }
        }
        
        if (!typeValue) return false; // Not a discriminated union pattern
        
        // Check if this case has a "value" property (associated value)
        const valueSchema = item.properties?.value;
        cases.push({
            typeValue: typeValue,
            hasValue: !!valueSchema,
            valueSchema: valueSchema
        });
    }
    
    // All items have type.const or single-value enum - this is a discriminated union
    const enumCases = [];
    const newProperties = {
        type: {
            type: 'string',
            enum: cases.map(c => c.typeValue)
        }
    };
    
    for (const caseInfo of cases) {
        const camelCaseName = snakeToCamel(caseInfo.typeValue);
        const enumCase = {
            name: camelCaseName,
            rawValue: caseInfo.typeValue,
            hasAssociatedValue: caseInfo.hasValue
        };
        
        if (caseInfo.hasValue && caseInfo.valueSchema) {
            const propName = `x_${caseInfo.typeValue}_value`;
            
            if (caseInfo.valueSchema.$ref) {
                const propSchema = {
                    allOf: [caseInfo.valueSchema],
                    'x-enum-case-name': camelCaseName,
                    'x-enum-case-raw-value': caseInfo.typeValue
                };
                newProperties[propName] = propSchema;
            } else {
                const syntheticSchemaName = `${schemaName}${caseInfo.typeValue.charAt(0).toUpperCase() + caseInfo.typeValue.slice(1)}Value`;
                allSchemas[syntheticSchemaName] = {
                    ...caseInfo.valueSchema,
                    'x-enum-case-name': camelCaseName,
                    'x-enum-case-raw-value': caseInfo.typeValue
                };
                const propSchema = {
                    allOf: [{ $ref: `#/components/schemas/${syntheticSchemaName}` }],
                    'x-enum-case-name': camelCaseName,
                    'x-enum-case-raw-value': caseInfo.typeValue
                };
                newProperties[propName] = propSchema;
            }
            enumCase.valuePropertyName = propName;
        }
        
        enumCases.push(enumCase);
    }
    
    // Replace anyOf with the processed structure
    delete schema.anyOf;
    schema.type = 'object';
    schema.properties = newProperties;
    schema['x-discriminated-union'] = true;
    schema['x-enum-cases'] = enumCases;
    
    const casesWithValues = enumCases.filter(c => c.hasAssociatedValue).length;
    const casesWithoutValues = enumCases.length - casesWithValues;
    
    console.error(`  ‚úì ${schemaName}: ${enumCases.length} cases (${casesWithValues} with values, ${casesWithoutValues} without) [anyOf pattern]`);
    
    return true;
}

/**
 * Check if a schema is an allOf-based discriminated union pattern and add vendor extensions.
 * This pattern is generated by ts-json-schema-generator WITH @discriminator.
 */
function processAllOfDiscriminatedUnion(schema, schemaName, allSchemas) {
    // Must have allOf with multiple items
    if (!schema.allOf || schema.allOf.length < 2) return false;
    
    // Must have properties.type.enum as discriminator
    const discriminatorValues = schema.properties?.type?.enum;
    if (!discriminatorValues || !Array.isArray(discriminatorValues)) return false;
    
    // Build the enum cases array with associated value schemas
    const enumCases = [];
    
    // Create new properties object with just the synthetic properties
    const newProperties = {
        type: schema.properties.type
    };
    
    for (const caseValue of discriminatorValues) {
        const valueInfo = getCaseValueInfo(schema.allOf, caseValue);
        const camelCaseName = snakeToCamel(caseValue);
        const caseInfo = {
            name: camelCaseName,
            rawValue: caseValue, // Original value for JSON encoding/decoding
            hasAssociatedValue: valueInfo.hasAssociatedValue
        };
        
        if (valueInfo.hasAssociatedValue && valueInfo.valueSchema) {
            // Add a synthetic property for this case's value
            // The property name format: x_<caseName>_value
            const propName = `x_${caseValue}_value`;
            
            // Check if valueSchema is a $ref or a primitive
            if (valueInfo.valueSchema.$ref) {
                // For $ref types, use allOf to combine the ref with the vendor extension
                // This ensures OpenAPI Generator preserves the extension on the var
                const propSchema = {
                    allOf: [valueInfo.valueSchema],
                    'x-enum-case-name': camelCaseName,
                    'x-enum-case-raw-value': caseValue
                };
                newProperties[propName] = propSchema;
            } else {
                // For primitive types, create a synthetic schema and reference it
                const syntheticSchemaName = `${schemaName}${caseValue.charAt(0).toUpperCase() + caseValue.slice(1)}Value`;
                allSchemas[syntheticSchemaName] = {
                    ...valueInfo.valueSchema,
                    'x-enum-case-name': camelCaseName,
                    'x-enum-case-raw-value': caseValue
                };
                const propSchema = {
                    allOf: [{ $ref: `#/components/schemas/${syntheticSchemaName}` }],
                    'x-enum-case-name': camelCaseName,
                    'x-enum-case-raw-value': caseValue
                };
                newProperties[propName] = propSchema;
            }
            caseInfo.valuePropertyName = propName;
        }
        
        enumCases.push(caseInfo);
    }
    
    // Replace the complex allOf structure with a simple object
    // This allows OpenAPI Generator to properly process the synthetic properties
    delete schema.allOf;
    schema.properties = newProperties;
    
    // Add the vendor extensions
    schema['x-discriminated-union'] = true;
    schema['x-enum-cases'] = enumCases;
    
    const casesWithValues = enumCases.filter(c => c.hasAssociatedValue).length;
    const casesWithoutValues = enumCases.length - casesWithValues;
    
    console.error(`  ‚úì ${schemaName}: ${enumCases.length} cases (${casesWithValues} with values, ${casesWithoutValues} without)`);
    
    return true;
}

// ============================================================================
// Main Pipeline
// ============================================================================

try {
    console.error('üìù Post-processing OpenAPI spec...');
    
    const spec = JSON.parse(fs.readFileSync(inputFile, 'utf8'));
    const schemas = spec.components?.schemas || spec.definitions || {};
    
    // Step 1: Fix integer types
    console.error('Step 1: Fixing integer types...');
    for (const [name, schema] of Object.entries(schemas)) {
        schemas[name] = fixIntegerTypes(schema);
    }
    console.error('  ‚úì Integer types fixed');
    
    // Step 2: Enrich discriminated unions (try both patterns)
    console.error('Step 2: Enriching discriminated unions...');
    let processedCount = 0;
    for (const [name, schema] of Object.entries(schemas)) {
        // Try allOf pattern first (with @discriminator), then anyOf pattern (without @discriminator)
        if (processAllOfDiscriminatedUnion(schema, name, schemas) || 
            processAnyOfDiscriminatedUnion(schema, name, schemas)) {
            processedCount++;
        }
    }
    console.error(`  ‚úì Processed ${processedCount} discriminated union schemas`);
    
    // Write output
    fs.writeFileSync(outputFile, JSON.stringify(spec, null, 2));
    console.error(`‚úÖ Output written to: ${outputFile}`);
    
} catch (error) {
    console.error('‚ùå Error processing OpenAPI spec:', error.message);
    console.error(error.stack);
    process.exit(1);
}
